C51 COMPILER V9.02   UART                                                                  05/16/2015 21:09:42 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN UART.OBJ
COMPILER INVOKED BY: E:\software\keil\C51\BIN\C51.EXE UART.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<reg51.h>
   2          #include<UART.h>
   3          
   4          #ifndef UART_BUFF_MAX
              #define UART_BUFF_MAX 64
              #endif // Èç¹ûÃ»ÓĞ¶¨ÒåBUFFMAX£¬ÔòÄ¬ÈÏÎª64
   7          
   8          #ifndef XTAL
              #define XTAL 11.059200
              #endif //Èç¹ûÃ»ÓĞ¶¨Òå¾§ÕñÆµÂÊ£¬ÔòÄ¬ÈÏÎª11.0592M¾§Õñ
  11          
  12          extern void UART_Action(unsigned char *dat, unsigned char len);
  13          //´Ëº¯ÊıĞëÁíĞĞ±àĞ´£ºµ±´®¿ÚÍê³ÉÒ»¸ö×Ö·û´®½áÊøºó»á×Ô¶¯µ÷ÓÃ
  14          sfr AUXR  = 0x8E; 
  15          //Auxiliary Register  T0x12 T1x12 UART_M0x6 BRTR S2SMOD BRTx12 EXTRAM S1BRS  0000,0000
  16          
  17          unsigned char pdata UART_Buff[UART_BUFF_MAX];     //´®¿Ú½ÓÊÕ»º³åÇø
  18          unsigned char UART_BuffIndex = 0;           //´®¿Ú½ÓÊÕ»º³åÇøµ±Ç°Î»ÖÃ
  19          
  20          bit UART_SendFlag;                          //´®¿Ú·¢ËÍÍê³É±êÖ¾
  21          bit UART_ResiveFlag;                        //´®¿Ú½ÓÊÕÍê³É±êÖ¾
  22          bit UART_ResiveStringEndFlag;               //´®¿Ú×Ö·û´®½ÓÊÕÈ«²¿Íê³É±êÖ¾
  23          bit UART_ResiveStringFlag;                  //´®¿Ú×Ö·û´®ÕıÔÚ½ÓÊÕ±êÖ¾
  24          
  25          /*///////////////////////////////////////////////////////////////////////////////////
  26          *º¯ÊıÃû£ºUART_Conf
  27          *º¯Êı¹¦ÄÜ£ºÅäÖÃ´®¿Ú
  28          *²ÎÊıÁĞ±í£º
  29          *   baud
  30          *       ²ÎÊıÀàĞÍ£ºunsigned charĞÍÊı¾İ
  31          *       ²ÎÊıÃèÊö£ºÒªÉèÖÃµÄ²¨ÌØÂÊ
  32          *·µ»ØÖµ£ºÎŞ
  33          *°æ±¾£º1.0
  34          *×÷Õß£ººÎÏàÁú
  35          *ÈÕÆÚ£º2014Äê12ÔÂ9ÈÕ
  36          *////////////////////////////////////////////////////////////////////////////////////
  37          void UART_Conf(unsigned int baud) //UARTÉèÖÃº¯Êı£¨buad£ºÓûÉèÖÃµÄ²¨ÌØÂÊ£©
  38          {
  39   1              AUXR &= 0xBF;           //¶¨Ê±Æ÷1Ê±ÖÓÎªFosc/12,¼´12T
  40   1              AUXR &= 0xFE;           //´®¿Ú1Ñ¡Ôñ¶¨Ê±Æ÷1Îª²¨ÌØÂÊ·¢ÉúÆ÷
  41   1              TL1 = TH1 = 256 - XTAL * 1000000 / 12 / 32 / baud;    //¼ÆËã¶¨Ê±Æ÷³õÖµ
  42   1              EA = 1;         //Ê¹ÄÜ×ÜÖĞ¶Ï
  43   1              ES = 1;         //Ê¹ÄÜ´®¿ÚÖĞ¶Ï
  44   1              TMOD &= 0X0F;   //ÅäÖÃ¶¨Ê±Æ÷1Îª×Ô¶¯ÖØ×°Ä£Ê½
  45   1              TMOD |= 0X20;
  46   1              SCON = 0X50;    //ÅäÖÃ´®¿Ú¹¤×÷Ä£Ê½
  47   1              TR1 = 1;        //Ê¹ÄÜ¶¨Ê±Æ÷1
  48   1      }
  49          /*///////////////////////////////////////////////////////////////////////////////////
  50          *º¯ÊıÃû£ºUART_SendString
  51          *º¯Êı¹¦ÄÜ£ºÏò´®¿Ú·¢ËÍÒ»¸ö×Ö·û´®
  52          *²ÎÊıÁĞ±í£º
  53          *   *dat
  54          *       ²ÎÊıÀàĞÍ£ºunsigned charĞÍÖ¸Õë
  55          *       ²ÎÊıÃèÊö£ºÒª·¢ËÍµÄ×Ö·û´®µÄÊ×µØÖ·
C51 COMPILER V9.02   UART                                                                  05/16/2015 21:09:42 PAGE 2   

  56          *   len
  57          *       ²ÎÊıÀàĞÍ£ºunsigned charĞÍÊı¾İ
  58          *       ²ÎÊıÃèÊö£ºÒª·¢ËÍµÄ×Ö·û´®µÄ³¤¶È
  59          *·µ»ØÖµ£ºÎŞ
  60          *°æ±¾£º1.0
  61          *×÷Õß£ººÎÏàÁú
  62          *ÈÕÆÚ£º2014Äê12ÔÂ9ÈÕ
  63          *////////////////////////////////////////////////////////////////////////////////////
  64          void UART_SendString(unsigned char *dat, unsigned char len)
  65          {
  66   1              while(len)
  67   1              {
  68   2                      len --;                     //Ã¿·¢ËÍÒ»Î»£¬³¤¶È¼õ1
  69   2                      SBUF = *dat;                //·¢ËÍÒ»Î»Êı¾İ
  70   2                      dat ++;                     //Êı¾İÖ¸ÕëÒÆÏòÏÂÒ»Î»
  71   2                      while(! UART_SendFlag);     //µÈ´ı´®¿Ú·¢ËÍÍê³É±êÖ¾
  72   2                      UART_SendFlag = 0;          //Çå¿Õ´®¿Ú·¢ËÍÍê³É±êÖ¾
  73   2              }
  74   1      }
  75          /*///////////////////////////////////////////////////////////////////////////////////
  76          *º¯ÊıÃû£ºUART_Read
  77          *º¯Êı¹¦ÄÜ£º½«Ôİ´æÊı×éÖĞµÄÊı¾İ¶ÁÈ¡³öÀ´¡£
  78          *²ÎÊıÁĞ±í£º
  79          *   *to
  80          *       ²ÎÊıÀàĞÍ£ºunsigned charĞÍÖ¸Õë
  81          *       ²ÎÊıÃèÊö£º´æ´¢½ÓÊÕµ½µÄ×Ö·ûµÄÎ»ÖÃ
  82          *   len
  83          *       ²ÎÊıÀàĞÍ£ºunsigned charĞÍÊı¾İ
  84          *       ²ÎÊıÃèÊö£ºÒª¶ÁÈ¡µÄ×Ö·û´®µÄ³¤¶È
  85          *·µ»ØÖµ£ºunsigned charĞÍÊı¾İ£¬×Ö·û´®µÄÊµ¼Ê³¤¶È
  86          *°æ±¾£º1.0
  87          *×÷Õß£ººÎÏàÁú
  88          *ÈÕÆÚ£º2014Äê12ÔÂ9ÈÕ
  89          *////////////////////////////////////////////////////////////////////////////////////
  90          unsigned char UART_Read(unsigned char *to, unsigned char len)
  91          {
  92   1              unsigned char i;
  93   1              if(UART_BuffIndex < len)len = UART_BuffIndex;   //»ñÈ¡µ±Ç°½ÓÊÕÊı¾İµÄÎ»Êı
  94   1              for(i = 0;i < len;i ++)                         //¸´ÖÆÊı¾İµÄÄ¿±êÊı×é
  95   1                      {
  96   2                              *to = UART_Buff[i];
  97   2                              to ++;
  98   2                      }
  99   1              UART_BuffIndex = 0;                             //Çå¿Õ´®¿Ú½ÓÊÕ»º³åÇøµ±Ç°Î»ÖÃ
 100   1              return len;
 101   1      }
 102          /*///////////////////////////////////////////////////////////////////////////////////
 103          *º¯ÊıÃû£ºUART_Driver
 104          *º¯Êı¹¦ÄÜ£º´®¿ÚÍ¨ĞÅ¼à¿Øº¯Êı£¬ÔÚÖ÷Ñ­»·ÖĞµ÷ÓÃ¡£
 105          *           Èç¹û½ÓÊÕµ½×Ö·û´®£¬»á×Ô¶¯µ÷ÓÃÁíĞĞ±àĞ´µÄUART_Action(unsigned char *dat,unsigned char len)
 106          *²ÎÊıÁĞ±í£º
 107          *   ÎŞ
 108          *·µ»ØÖµ£ºÎŞ
 109          *°æ±¾£º1.0
 110          *×÷Õß£ººÎÏàÁú
 111          *ÈÕÆÚ£º2014Äê12ÔÂ9ÈÕ
 112          *////////////////////////////////////////////////////////////////////////////////////
 113          void UART_Driver()//
 114          {
 115   1              unsigned char pdata dat[UART_BUFF_MAX];       //¶¨ÒåÊı¾İÔİ´æÊı×é
 116   1              unsigned char len;                      //Êı¾İµÄ³¤¶È
 117   1              if(UART_ResiveStringEndFlag)            //Èç¹û´®¿Ú½ÓÊÕµ½Ò»¸öÍêÕûµÄ×Ö·û´®
C51 COMPILER V9.02   UART                                                                  05/16/2015 21:09:42 PAGE 3   

 118   1                      {
 119   2                              UART_ResiveStringEndFlag = 0;   //Çå¿Õ½ÓÊÕÍê³É±êÖ¾
 120   2                              len = UART_Read(dat, UART_BUFF_MAX);  //½«Êı¾İ´ÓÔ­Êı×é¶Á³ö£¬²¢µÃµ½Êı¾İµÄ³¤¶È
 121   2                              UART_Action(dat, len);          //µ÷ÓÃÓÃ»§±àĞ´µÄUART_Actionº¯Êı£¬½«½ÓÊÕµ½µÄÊı¾İ¼°Êı¾İ³¤¶È×÷Îª²ÎÊı
 122   2                      }
 123   1      }
 124          /*///////////////////////////////////////////////////////////////////////////////////
 125          *º¯ÊıÃû£ºUART_RxMonitor
 126          *º¯Êı¹¦ÄÜ£º´®¿Ú×Ö·û´®½ÓÊÕ½áÊøÅĞ¶Ï£¬ÔÚ¶¨Ê±Æ÷0ÖĞ¶Ïº¯ÊıÖĞµ÷ÓÃ
 127          *²ÎÊıÁĞ±í£º
 128          *   ms
 129          *       ²ÎÊıÀàĞÍ£ºunsigned charĞÍÊı¾İ
 130          *       ²ÎÊıÃèÊö£º¶¨Ê±Æ÷ÑÓÊ±Ê±³¤£¨µ¥Î»£ºms£©
 131          *·µ»ØÖµ£ºÎŞ
 132          *°æ±¾£º1.0
 133          *×÷Õß£ººÎÏàÁú
 134          *ÈÕÆÚ£º2014Äê12ÔÂ9ÈÕ
 135          *////////////////////////////////////////////////////////////////////////////////////
 136          void UART_RxMonitor(unsigned char ms)
 137          {
 138   1              static unsigned char ms30 = 0;                  //30ºÁÃë¼ÆÊ±
 139   1              static unsigned char UART_BuffIndex_Backup;     //´®¿ÚÊı¾İÔİ´æÊı×éÎ»ÖÃ±¸·İ
 140   1              if(! UART_ResiveStringFlag)return ;             //Èç¹ûµ±Ç°Ã»ÓĞÔÚ½ÓÊÜÊı¾İ£¬Ö±½ÓÍË³öº¯Êı
 141   1          ms30 += ms;                                     //Ã¿Ò»´Î¶¨Ê±Æ÷ÖĞ¶Ï£¬±íÊ¾Ê±¼ä¹ıÈ¥ÁËÈô¸ÉºÁÃë
 142   1              if(UART_BuffIndex_Backup != UART_BuffIndex)     //Èç¹û´®¿ÚÊı¾İÔİ´æÊı×éÎ»ÖÃ±¸·İ²»µÈÓÚ´®¿Ú½ÓÊÕ»º³åÇøµ±Ç°Î»Ö
             -Ã£¨½ÓÊÕµ½ÁËĞÂÊı¾İÎ»£©
 143   1              {
 144   2                      UART_BuffIndex_Backup = UART_BuffIndex;     //¼ÇÂ¼µ±Ç°µÄ´®¿Ú½ÓÊÕ»º³åÇøÎ»ÖÃ
 145   2                      ms30 = 0;                                   //¸´Î»30ºÁÃë¼ÆÊ±
 146   2              }
 147   1              if(ms30 > 30)                                   //30ºÁÃëµ½ÁË
 148   1                      {
 149   2                              ms30 = 0;                               //¸´Î»30ºÁÃë¼ÆÊ±
 150   2                              UART_ResiveStringEndFlag = 1;           //ÉèÖÃ´®¿Ú×Ö·û´®½ÓÊÕÈ«²¿Íê³É±êÖ¾
 151   2                              UART_ResiveStringFlag = 0;              //Çå¿Õ´®¿Ú×Ö·û´®ÕıÔÚ½ÓÊÕ±êÖ¾
 152   2                      }
 153   1      }
 154          /*///////////////////////////////////////////////////////////////////////////////////
 155          *º¯ÊıÃû£ºinterrupt_UART
 156          *º¯Êı¹¦ÄÜ£º´®¿ÚÖĞ¶Ïº¯Êı
 157          *²ÎÊıÁĞ±í£º
 158          *   ÎŞ
 159          *·µ»ØÖµ£ºÎŞ
 160          *°æ±¾£º1.0
 161          *×÷Õß£ººÎÏàÁú
 162          *ÈÕÆÚ£º2014Äê12ÔÂ9ÈÕ
 163          *////////////////////////////////////////////////////////////////////////////////////
 164          void interrupt_UART() interrupt 4
 165          {
 166   1              if(TI)                                  //Èç¹û´®¿Ú·¢ËÍÍê³É
 167   1              {
 168   2                      TI = 0;                             //Çå¿ÕÏµÍ³±êÖ¾Î»
 169   2                      UART_SendFlag = 1;                  //ÉèÖÃ´®¿Ú·¢ËÍÍê³É±êÖ¾
 170   2              }
 171   1              if(RI)                                  //Èç¹û´®¿Ú½ÓÊÕÍê³É
 172   1              {
 173   2                      RI = 0;                             //Çå¿ÕÏµÍ³±êÖ¾Î»
 174   2                      UART_ResiveFlag = 1;                //ÉèÖÃ´®¿Ú½ÓÊÕÍê³É±êÖ¾
 175   2                      UART_Buff[UART_BuffIndex] = SBUF;   //½«½ÓÊÕµ½µÄÊı¾İ·Åµ½Ôİ´æÊı×é
 176   2                      UART_ResiveStringFlag = 1;          //ÉèÖÃ´®¿Ú×Ö·û´®ÕıÔÚ½ÓÊÕ±êÖ¾
 177   2                      UART_BuffIndex ++;                  //´®¿Ú½ÓÊÕ»º³åÇøµ±Ç°Î»ÖÃÓÒÒÆ
 178   2              }
C51 COMPILER V9.02   UART                                                                  05/16/2015 21:09:42 PAGE 4   

 179   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    239    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     64      64
   DATA SIZE        =      3    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
